import {
  AbiParameter,
  Contract,
  FunctionDeclaration,
  parse,
  RawAbiDefinition
} from "./abiParser";
import { getVersion } from "./utils";
import { EvmType, ArrayType } from "./typeParser";

export interface IContext {
  fileName: string;
  relativeRuntimePath: string;
}

export function generateSource(abi: Array<RawAbiDefinition>, context: IContext): string {
  const parsedContractAbi = parse(abi);

  return codeGenForContract(abi, parsedContractAbi, context);
}

// @todo better typings for web3
function codeGenForContract(abi: Array<RawAbiDefinition>, input: Contract, context: IContext) {
  const typeName = `${context.fileName}`;
  const constructorParams = input.constructor.inputs
    .map(codeGenForParams)
    .concat("options?: any")
    .join(", ")
  return `/* GENERATED BY TYPECHAIN VER. ${getVersion()} */
/* tslint:disable */
import { Transaction, Receipt, ReceiptLog, Event, EventArgs, TruffleContract } from "./typechain-runtime";

// Types for view functions
${input.constantFunctions.map(generateViewFunctionType).join(";\n\n")}

// Types for functions
${input.functions.map(generateFunctionType).join(";\n\n")}

export declare class ${typeName} extends TruffleContract {
    static new(${constructorParams}): Promise<${typeName}>
    static at(address: string): Promise<${typeName}>
    static deployed(): Promise<${typeName}>

    // View functions
    ${input.constantFunctions.map(generateFunctionDeclaration).join(";\n")}

    // Functions
    ${input.functions.map(generateFunctionDeclaration).join(";\n")}
  }`;
}

function codeGenForParams(param: AbiParameter, index: number): string {
  return `${param.name || `arg${index}`}: ${param.type.generateCodeForInput()}`;
}

function codeGenForArgs(param: AbiParameter, index: number): string {
  const isArray = param.type instanceof ArrayType;
  const paramName = param.name || `arg${index}`;
  return isArray ? `${paramName}.map(val => val.toString())` : `${paramName}.toString()`;
}

function codeGenForOutputTypeList(output: Array<EvmType>): string {
  if (output.length === 1) {
    return output[0].generateCodeForOutput();
  } else {
    return `[${output.map(x => x.generateCodeForOutput()).join(", ")}]`;
  }
}

function generateViewFunctionType(constantFunction: FunctionDeclaration) {
  const params = `(${constantFunction.inputs
      .map(codeGenForParams)
      .join(", ")})`
  const outputs = codeGenForOutputTypeList(constantFunction.outputs)
  const functionHeader: string = `${params}: Promise<${outputs}>`;
  const functionType: string = `${params} => Promise<${outputs}>`;
  return `interface ${constantFunction.name}Type {
    ${functionHeader};
    call: ${functionType};
  };`;
}

function generateFunctionType(func: FunctionDeclaration) {
  const params = `(${func.inputs
      .map(codeGenForParams)
      .concat("options?: any")
      .join(", ")})`
  const outputs = codeGenForOutputTypeList(func.outputs)
  const functionHeader: string = `${params}: Promise<Transaction>`;
  const functionType: string = `${params} => Promise<${outputs}>`;
  return `interface ${func.name}Type {
    ${functionHeader};
    call: ${functionType};
  };`;
}

function generateFunctionDeclaration(func: FunctionDeclaration) {
  return `public ${func.name}: ${func.name}Type`
}
